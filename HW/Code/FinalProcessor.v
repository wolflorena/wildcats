/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule

module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule


module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module ControlUnit (
  input [3:0] Fl,
  input [5:0] Op,
  input [4:0] Fu,
  output Br,
  output We,
  output A,
  output Ld,
  output Str,
  output Jmp,
  output En,
  output [4:0] Ctrl,
  output push,
  output pop
);
  wire A_temp;
  wire Ld_temp;
  wire [4:0] s0;
  wire Jmp_temp;
  wire s1;
  wire s2;
  wire push_temp;
  wire s3;
  wire s4;
  wire s5;
  wire pop_temp;
  wire s6;
  assign s0 = Op[4:0];
  assign Jmp_temp = Op[5];
  assign s4 = s0[0];
  assign s2 = s0[1];
  assign s1 = s0[2];
  assign s5 = s0[3];
  assign s3 = s0[4];
  assign push_temp = (Jmp_temp & ~ s3 & ~ s5 & s1 & s2 & ~ s4);
  assign pop_temp = (Jmp_temp & ~ s3 & ~ s5 & s1 & s2 & s4);
  assign s6 = ~ (s4 | s2 | s1 | s5 | s3 | Jmp_temp);
  assign Ld_temp = (~ Jmp_temp & ~ s3 & ~ s5 & ~ s1 & ~ s2 & s4);
  assign Str = (~ Jmp_temp & ~ s3 & ~ s5 & ~ s1 & s2 & ~ s4);
  assign Br = ((Jmp_temp & ~ s3 & ~ s5 & ~ s1 & ~ s2 & s4 & Fl[3]) | (Jmp_temp & ~ s3 & ~ s5 & ~ s1 & s2 & ~ s4 & Fl[2]) | (Jmp_temp & ~ s3 & ~ s5 & ~ s1 & s2 & s4 & Fl[1]) | (Jmp_temp & ~ s3 & ~ s5 & s1 & ~ s2 & ~ s4 & Fl[0]) | (Jmp_temp & ~ s3 & ~ s5 & s1 & ~ s2 & s4));
  assign En = (push_temp | pop_temp);
  assign A_temp = (s6 & ~ Fu[4] & Fu[3] & ~ Fu[2] & ~ Fu[1] & Fu[0]);
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i0 (
    .sel( s6 ),
    .in_0( s0 ),
    .in_1( Fu ),
    .out( Ctrl )
  );
  assign We = ((~ Jmp_temp & ~ s3 & s5 & ~ s1 & ~ s2 & s4) | A_temp | Ld_temp);
  assign A = A_temp;
  assign Ld = Ld_temp;
  assign Jmp = Jmp_temp;
  assign push = push_temp;
  assign pop = pop_temp;
endmodule

module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module ADD (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  wire s2;
  wire s3;
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s0 ),
    .c_o( s1 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i1 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s3 )
  );
  assign s2 = s0[15];
  assign out[15:0] = s0;
  assign out[16] = ((s2 & ~ a[15] & ~ b[15]) | (~ s2 & b[15] & a[15]));
  assign out[17] = s1;
  assign out[18] = s2;
  assign out[19] = s3;
endmodule

module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module SUB (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  wire s2;
  wire s3;
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i0 (
    .a( a ),
    .b( b ),
    .c_i( 1'b0 ),
    .s( s0 ),
    .c_o( s1 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i1 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s3 )
  );
  assign s2 = s0[15];
  assign out[15:0] = s0;
  assign out[16] = (~ (s2 ^ b[15]) & (b[15] ^ a[15]));
  assign out[17] = s1;
  assign out[18] = s2;
  assign out[19] = s3;
endmodule

module DIG_Mul_signed #(
    parameter Bits = 1
)
(
    
      input signed [(Bits-1):0] a,
      input signed [(Bits-1):0] b,
      output signed [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule


module MUL (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  wire s2;
  wire [31:0] s3;
  wire [15:0] s4;
  wire s5;
  wire s6;
  DIG_Mul_signed #(
    .Bits(16)
  )
  DIG_Mul_signed_i0 (
    .a( a ),
    .b( b ),
    .mul( s3 )
  );
  assign s1 = s3[15];
  assign s4 = s3[31:16];
  assign s0 = s3[15:0];
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i1 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s2 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( 16'b0 ),
    .b( s4 ),
    .\= ( s5 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i3 (
    .a( 16'b1111111111111111 ),
    .b( s4 ),
    .\= ( s6 )
  );
  assign out[15:0] = s0;
  assign out[16] = ((~ a[15] & ~ b[15] & s1) | (~ a[15] & b[15] & ~ s1) | (~ s6 & ~ s5) | (a[15] & ~ b[15] & ~ s1) | (a[15] & b[15] & s1));
  assign out[17] = 1'b0;
  assign out[18] = s1;
  assign out[19] = s2;
endmodule

module \AND  (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  assign s0 = (a & b);
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s1 )
  );
  assign out[15:0] = s0;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = s0[15];
  assign out[19] = s1;
endmodule

module \OR  (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  assign s0 = (a | b);
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s1 )
  );
  assign out[15:0] = s0;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = s0[15];
  assign out[19] = s1;
endmodule

module \XOR  (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  assign s0 = (a ^ b);
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s1 )
  );
  assign out[15:0] = s0;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = s0[15];
  assign out[19] = s1;
endmodule

module \NOT  (
  input [15:0] a,
  output [19:0] out
);
  wire [15:0] s0;
  wire s1;
  assign s0 = ~ a;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( 16'b0 ),
    .b( s0 ),
    .\= ( s1 )
  );
  assign out[15:0] = s0;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = s0[15];
  assign out[19] = s1;
endmodule

module CMP (
  input [15:0] a,
  input [15:0] b,
  output [19:0] out
);
  wire s0;
  wire s1;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( a ),
    .b( b ),
    .\= ( s0 ),
    .\< ( s1 )
  );
  assign out[15:0] = 16'b0;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = s1;
  assign out[19] = s0;
endmodule

module INC (
  input [15:0] a,
  output [19:0] out
);
  wire [15:0] s0;
  assign s0[0] = 1'b1;
  assign s0[15:1] = 15'b0;
  ADD ADD_i0 (
    .a( a ),
    .b( s0 ),
    .out( out )
  );
endmodule

module DEC (
  input [15:0] a,
  output [19:0] out
);
  wire [15:0] s0;
  assign s0[0] = 1'b1;
  assign s0[15:1] = 15'b0;
  SUB SUB_i0 (
    .a( a ),
    .b( s0 ),
    .out( out )
  );
endmodule

module THROUGH (
  input [15:0] a,
  output [19:0] out
);
  assign out[15:0] = a;
  assign out[16] = 1'b0;
  assign out[17] = 1'b0;
  assign out[18] = 1'b0;
  assign out[19] = 1'b0;
endmodule

module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module DriverBus#(
    parameter Bits = 2
)
(
    input [(Bits-1):0] in,
    input sel,
    output [(Bits-1):0] out
);
    assign out = (sel == 1'b1)? in : {Bits{1'bz}};
endmodule

module Driver
(
    input in,
    input sel,
    output out
);
    assign out = (sel == 1'b1)? in : 1'bz;
endmodule

module \LogicShiftLeft(LSL)  (
  input CLK,
  input [15:0] A,
  input [15:0] B,
  output [19:0] out
);
  wire s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [14:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [19:0] s8;
  wire s9;
  wire [15:0] s10;
  wire s11;
  wire s12;
  wire s13;
  DIG_Register DIG_Register_i0 (
    .D( CLK ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s0 ),
    .in_0( A ),
    .in_1( s3 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( B ),
    .in_1( s7 ),
    .out( s5 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s5 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s6 )
  );
  DEC DEC_i5 (
    .a( s6 ),
    .out( s8 )
  );
  assign s4 = s2[15:1];
  assign s3[14:0] = s4;
  assign s3[15] = s4[14];
  assign s7 = s8[15:0];
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i6 (
    .a( 16'b0 ),
    .b( s7 ),
    .\= ( s9 )
  );
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i7 (
    .in( s3 ),
    .sel( s9 ),
    .out( s10 )
  );
  Driver Driver_i8 (
    .in( 1'b0 ),
    .sel( s9 ),
    .out( s11 )
  );
  Driver Driver_i9 (
    .in( 1'b0 ),
    .sel( s9 ),
    .out( s12 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i10 (
    .a( 16'b0 ),
    .b( s10 ),
    .\= ( s13 )
  );
  assign out[15:0] = s10;
  assign out[16] = s11;
  assign out[17] = s12;
  assign out[18] = s10[15];
  assign out[19] = s13;
endmodule

module \LogicShiftRight(LSR)  (
  input CLK,
  input [15:0] A,
  input [15:0] B,
  output [19:0] out
);
  wire s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [19:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire s11;
  wire s12;
  DIG_Register DIG_Register_i0 (
    .D( CLK ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s0 ),
    .in_0( A ),
    .in_1( s3 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( B ),
    .in_1( s6 ),
    .out( s4 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s4 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s5 )
  );
  DEC DEC_i5 (
    .a( s5 ),
    .out( s7 )
  );
  assign s3[0] = 1'b0;
  assign s3[15:1] = s2[14:0];
  assign s6 = s7[15:0];
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i6 (
    .a( 16'b0 ),
    .b( s6 ),
    .\= ( s8 )
  );
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i7 (
    .in( s3 ),
    .sel( s8 ),
    .out( s9 )
  );
  Driver Driver_i8 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s10 )
  );
  Driver Driver_i9 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s11 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i10 (
    .a( 16'b0 ),
    .b( s9 ),
    .\= ( s12 )
  );
  assign out[15:0] = s9;
  assign out[16] = s10;
  assign out[17] = s11;
  assign out[18] = s9[15];
  assign out[19] = s12;
endmodule

module \RotateShiftLeft(RSL)  (
  input CLK,
  input [15:0] A,
  input [15:0] B,
  output [19:0] out
);
  wire s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [19:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire s11;
  wire s12;
  DIG_Register DIG_Register_i0 (
    .D( CLK ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s0 ),
    .in_0( A ),
    .in_1( s3 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( B ),
    .in_1( s6 ),
    .out( s4 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s4 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s5 )
  );
  DEC DEC_i5 (
    .a( s5 ),
    .out( s7 )
  );
  assign s3[0] = s2[15];
  assign s3[15:1] = s2[14:0];
  assign s6 = s7[15:0];
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i6 (
    .a( 16'b0 ),
    .b( s6 ),
    .\= ( s8 )
  );
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i7 (
    .in( s3 ),
    .sel( s8 ),
    .out( s9 )
  );
  Driver Driver_i8 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s10 )
  );
  Driver Driver_i9 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s11 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i10 (
    .a( 16'b0 ),
    .b( s9 ),
    .\= ( s12 )
  );
  assign out[15:0] = s9;
  assign out[16] = s10;
  assign out[17] = s11;
  assign out[18] = s9[15];
  assign out[19] = s12;
endmodule

module \RotateShiftRight(RSR)  (
  input CLK,
  input [15:0] A,
  input [15:0] B,
  output [19:0] out
);
  wire s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [19:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire s11;
  wire s12;
  DIG_Register DIG_Register_i0 (
    .D( CLK ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s0 ),
    .in_0( A ),
    .in_1( s3 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( s0 ),
    .in_0( B ),
    .in_1( s6 ),
    .out( s4 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s1 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s4 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s5 )
  );
  DEC DEC_i5 (
    .a( s5 ),
    .out( s7 )
  );
  assign s3[14:0] = s2[15:1];
  assign s3[15] = s2[0];
  assign s6 = s7[15:0];
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i6 (
    .a( 16'b0 ),
    .b( s6 ),
    .\= ( s8 )
  );
  DriverBus #(
    .Bits(16)
  )
  DriverBus_i7 (
    .in( s3 ),
    .sel( s8 ),
    .out( s9 )
  );
  Driver Driver_i8 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s10 )
  );
  Driver Driver_i9 (
    .in( 1'b0 ),
    .sel( s8 ),
    .out( s11 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i10 (
    .a( 16'b0 ),
    .b( s9 ),
    .\= ( s12 )
  );
  assign out[15:0] = s9;
  assign out[16] = s10;
  assign out[17] = s11;
  assign out[18] = s9[15];
  assign out[19] = s12;
endmodule
